{"ast":null,"code":"import * as anchor from '@project-serum/anchor';\nimport { MintLayout, Token } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport { sendTransactions } from './connection';\nimport idlMagicHat from './magic_hat.json';\nimport { CIVIC, getAtaForMint, getNetworkExpire, getNetworkToken } from './utils';\nimport { SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, TOKEN_PROGRAM_ID, MAGIC_HAT_ID } from './config'; // import idl from \"./wallet_whitelist.json\";\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');\nconst MAGIC_HAT_PROGRAM_V2_ID = new anchor.web3.PublicKey('AGydXrbh2V9RH3h3cDzpws51tRDs2HbTtUXnCkq58bwH');\nexport const awaitTransactionSignatureConfirmation = async function (txid, timeout, connection) {\n  let queryStatus = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({\n        timeout: true\n      });\n    }, timeout);\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n\n      await sleep(2000);\n    }\n  }); //@ts-ignore\n\n  if (connection && connection._signatureSubscriptions && connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n\n  done = true;\n  console.log('Returning status', status);\n  return status;\n};\n\nconst createAssociatedTokenAccountInstruction = (associatedTokenAddress, payer, walletAddress, splTokenMintAddress) => {\n  const keys = [{\n    pubkey: payer,\n    isSigner: true,\n    isWritable: true\n  }, {\n    pubkey: associatedTokenAddress,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: walletAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: splTokenMintAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: anchor.web3.SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: TOKEN_PROGRAM_ID,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([])\n  });\n};\n\nexport const getMagicHatState = async (anchorWallet, magicHatId, connection) => {\n  var _state$data$goLiveDat;\n\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'recent'\n  });\n  const idl = idlMagicHat;\n  const program = new anchor.Program(idl, MAGIC_HAT_PROGRAM_V2_ID, provider);\n  const state = await program.account.magicHat.fetch(magicHatId);\n  console.log(state.authority.toBase58());\n  const itemsAvailable = state.data.itemsAvailable.toNumber();\n  const itemsRedeemed = state.itemsRedeemed.toNumber();\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\n  const presale = state.data.whitelistMintSettings && state.data.whitelistMintSettings.presale && (!state.data.goLiveDate || state.data.goLiveDate.toNumber() > new Date().getTime() / 1000);\n  return {\n    id: magicHatId,\n    program,\n    state: {\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      isSoldOut: itemsRemaining === 0,\n      isActive: (presale || ((_state$data$goLiveDat = state.data.goLiveDate) === null || _state$data$goLiveDat === void 0 ? void 0 : _state$data$goLiveDat.toNumber()) < new Date().getTime() / 1000) && (state.data.endSettings ? state.data.endSettings.endSettingType.date ? state.data.endSettings.number.toNumber() > new Date().getTime() / 1000 : itemsRedeemed < state.data.endSettings.number.toNumber() : true),\n      isPresale: presale,\n      goLiveDate: state.data.goLiveDate,\n      treasury: state.wallet,\n      tokenMint: state.tokenMint,\n      gatekeeper: state.data.gatekeeper,\n      endSettings: state.data.endSettings,\n      whitelistMintSettings: state.data.whitelistMintSettings,\n      hiddenSettings: state.data.hiddenSettings,\n      price: state.data.price\n    }\n  };\n};\n\nconst getMasterEdition = async mint => {\n  return (await anchor.web3.PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer(), Buffer.from('edition')], TOKEN_METADATA_PROGRAM_ID))[0];\n};\n\nconst getMetadata = async mint => {\n  return (await anchor.web3.PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()], TOKEN_METADATA_PROGRAM_ID))[0];\n};\n\nexport const getMagicHatCreator = async magicHat => {\n  return await anchor.web3.PublicKey.findProgramAddress([Buffer.from('magic_hat'), magicHat.toBuffer()], MAGIC_HAT_PROGRAM_V2_ID);\n};\nexport const mintOneToken = async (magicHat, payer, wallet, id) => {\n  const mint = anchor.web3.Keypair.generate();\n  const userTokenAccountAddress = (await getAtaForMint(mint.publicKey, payer))[0];\n  const userPayingAccountAddress = magicHat.state.tokenMint ? (await getAtaForMint(magicHat.state.tokenMint, payer))[0] : payer;\n  const MAGIC_HAT_ID = magicHat.id;\n  console.log(MAGIC_HAT_ID.toBase58());\n  const remainingAccounts = [];\n  const signers = [mint];\n  const cleanupInstructions = [];\n  const instructions = [anchor.web3.SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: mint.publicKey,\n    space: MintLayout.span,\n    lamports: await magicHat.program.provider.connection.getMinimumBalanceForRentExemption(MintLayout.span),\n    programId: TOKEN_PROGRAM_ID\n  }), Token.createInitMintInstruction(TOKEN_PROGRAM_ID, mint.publicKey, 0, payer, payer), createAssociatedTokenAccountInstruction(userTokenAccountAddress, payer, payer, mint.publicKey), Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint.publicKey, userTokenAccountAddress, payer, [], 1)];\n\n  if (magicHat.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (await getNetworkToken(payer, magicHat.state.gatekeeper.gatekeeperNetwork))[0],\n      isWritable: true,\n      isSigner: false\n    });\n\n    if (magicHat.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false\n      });\n      remainingAccounts.push({\n        pubkey: (await getNetworkExpire(magicHat.state.gatekeeper.gatekeeperNetwork))[0],\n        isWritable: false,\n        isSigner: false\n      });\n    }\n  }\n\n  if (magicHat.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(magicHat.state.whitelistMintSettings.mint);\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false\n    });\n\n    if (magicHat.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists = await magicHat.program.provider.connection.getAccountInfo(whitelistToken);\n\n      if (exists) {\n        instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, whitelistToken, whitelistBurnAuthority.publicKey, payer, [], 1));\n        cleanupInstructions.push(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, whitelistToken, payer, []));\n      }\n    }\n  }\n\n  if (magicHat.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n\n    for (let index = 0; index < remainingAccounts.length; index++) {\n      let element = remainingAccounts[index];\n\n      if (element.pubkey === userPayingAccountAddress) {\n        console.log('Already Minted !!!');\n      }\n    }\n\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true\n    });\n    instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, userPayingAccountAddress, transferAuthority.publicKey, payer, [], magicHat.state.price.toNumber()));\n    cleanupInstructions.push(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, userPayingAccountAddress, payer, []));\n  }\n\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n  const [magicHatCreator, creatorBump] = await getMagicHatCreator(MAGIC_HAT_ID);\n  instructions.push(await magicHat.program.instruction.mintNft(creatorBump, {\n    accounts: {\n      magicHat: MAGIC_HAT_ID,\n      magicHatCreator,\n      payer: payer,\n      wallet: magicHat.state.treasury,\n      metadata: metadataAddress,\n      mint: mint.publicKey,\n      mintAuthority: payer,\n      updateAuthority: payer,\n      masterEdition,\n      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n      tokenProgram: TOKEN_PROGRAM_ID,\n      systemProgram: SystemProgram.programId,\n      rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n      clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n      recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n      instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY\n    },\n    remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined\n  }));\n\n  try {\n    return (await sendTransactions(magicHat.program.provider.connection, magicHat.program.provider.wallet, [instructions, cleanupInstructions], [signers, []])).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\nexport const mintOneTokenWL = async (magicHat, payer, wallet_pda) => {\n  const mint = anchor.web3.Keypair.generate();\n  const userTokenAccountAddress = (await getAtaForMint(mint.publicKey, payer))[0];\n  const userPayingAccountAddress = magicHat.state.tokenMint ? (await getAtaForMint(magicHat.state.tokenMint, payer))[0] : payer;\n  const remainingAccounts = [];\n  const signers = [mint];\n  const cleanupInstructions = [];\n  const instructions = [anchor.web3.SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: mint.publicKey,\n    space: MintLayout.span,\n    lamports: await magicHat.program.provider.connection.getMinimumBalanceForRentExemption(MintLayout.span),\n    programId: TOKEN_PROGRAM_ID\n  }), Token.createInitMintInstruction(TOKEN_PROGRAM_ID, mint.publicKey, 0, payer, payer), createAssociatedTokenAccountInstruction(userTokenAccountAddress, payer, payer, mint.publicKey), Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint.publicKey, userTokenAccountAddress, payer, [], 1)];\n\n  if (magicHat.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (await getNetworkToken(payer, magicHat.state.gatekeeper.gatekeeperNetwork))[0],\n      isWritable: true,\n      isSigner: false\n    });\n\n    if (magicHat.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false\n      });\n      remainingAccounts.push({\n        pubkey: (await getNetworkExpire(magicHat.state.gatekeeper.gatekeeperNetwork))[0],\n        isWritable: false,\n        isSigner: false\n      });\n    }\n  }\n\n  if (magicHat.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(magicHat.state.whitelistMintSettings.mint);\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false\n    });\n\n    if (magicHat.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists = await magicHat.program.provider.connection.getAccountInfo(whitelistToken);\n\n      if (exists) {\n        instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, whitelistToken, whitelistBurnAuthority.publicKey, payer, [], 1));\n        cleanupInstructions.push(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, whitelistToken, payer, []));\n      }\n    }\n  }\n\n  if (magicHat.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n\n    for (let index = 0; index < remainingAccounts.length; index++) {\n      let element = remainingAccounts[index];\n\n      if (element.pubkey === userPayingAccountAddress) {\n        console.log('Already Minted !!!');\n      }\n    }\n\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true\n    });\n    instructions.push(Token.createApproveInstruction(TOKEN_PROGRAM_ID, userPayingAccountAddress, transferAuthority.publicKey, payer, [], magicHat.state.price.toNumber()));\n    cleanupInstructions.push(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, userPayingAccountAddress, payer, []));\n  }\n\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n  const [magicHatCreator, creatorBump] = await getMagicHatCreator(MAGIC_HAT_ID);\n  console.log(MAGIC_HAT_ID.toBase58());\n  instructions.push(await magicHat.program.instruction.wlMintNft(creatorBump, {\n    accounts: {\n      magicHat: MAGIC_HAT_ID,\n      walletWhitelist: wallet_pda,\n      magicHatCreator: magicHatCreator,\n      whitelistedAddress: payer,\n      wallet: magicHat.state.treasury,\n      metadata: metadataAddress,\n      mint: mint.publicKey,\n      mintAuthority: payer,\n      updateAuthority: payer,\n      masterEdition,\n      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n      tokenProgram: TOKEN_PROGRAM_ID,\n      systemProgram: SystemProgram.programId,\n      rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n      clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n      recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n      instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY\n    },\n    remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined\n  }));\n\n  try {\n    return (await sendTransactions(magicHat.program.provider.connection, magicHat.program.provider.wallet, [instructions, cleanupInstructions], [signers, []])).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\nexport const shortenAddress = function (address) {\n  let chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};","map":{"version":3,"names":["anchor","MintLayout","Token","SystemProgram","sendTransactions","idlMagicHat","CIVIC","getAtaForMint","getNetworkExpire","getNetworkToken","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","TOKEN_PROGRAM_ID","MAGIC_HAT_ID","TOKEN_METADATA_PROGRAM_ID","web3","PublicKey","MAGIC_HAT_PROGRAM_V2_ID","awaitTransactionSignatureConfirmation","txid","timeout","connection","queryStatus","done","status","slot","confirmations","err","subId","Promise","resolve","reject","setTimeout","console","log","signatureStatuses","getSignatureStatuses","value","e","sleep","_signatureSubscriptions","removeSignatureListener","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","programId","SYSVAR_RENT_PUBKEY","TransactionInstruction","data","Buffer","from","getMagicHatState","anchorWallet","magicHatId","provider","Provider","preflightCommitment","idl","program","Program","state","account","magicHat","fetch","authority","toBase58","itemsAvailable","toNumber","itemsRedeemed","itemsRemaining","presale","whitelistMintSettings","goLiveDate","Date","getTime","id","isSoldOut","isActive","endSettings","endSettingType","date","number","isPresale","treasury","wallet","tokenMint","gatekeeper","hiddenSettings","price","getMasterEdition","mint","findProgramAddress","toBuffer","getMetadata","getMagicHatCreator","mintOneToken","Keypair","generate","userTokenAccountAddress","publicKey","userPayingAccountAddress","remainingAccounts","signers","cleanupInstructions","instructions","createAccount","fromPubkey","newAccountPubkey","space","span","lamports","getMinimumBalanceForRentExemption","createInitMintInstruction","createMintToInstruction","push","gatekeeperNetwork","expireOnUse","whitelistToken","mode","burnEveryTime","whitelistBurnAuthority","exists","getAccountInfo","createApproveInstruction","createRevokeInstruction","transferAuthority","index","length","element","metadataAddress","masterEdition","magicHatCreator","creatorBump","instruction","mintNft","accounts","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_RECENT_BLOCKHASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","undefined","txs","map","t","mintOneTokenWL","wallet_pda","wlMintNft","walletWhitelist","whitelistedAddress","shortenAddress","address","chars","slice","ms"],"sources":["/Users/vamshikrishnaenjapuri/magic_hat_ui/src/candy-machine.ts"],"sourcesContent":["import * as anchor from '@project-serum/anchor';\n\nimport { MintLayout, Token } from '@solana/spl-token';\nimport { PublicKey, SystemProgram } from '@solana/web3.js';\nimport { sendTransactions } from './connection';\nimport idlMagicHat from './magic_hat.json';\n\nimport {\n  CIVIC,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken\n} from './utils';\nimport { SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, TOKEN_PROGRAM_ID, MAGIC_HAT_ID } from './config';\n// import idl from \"./wallet_whitelist.json\";\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',\n);\n\nconst MAGIC_HAT_PROGRAM_V2_ID = new anchor.web3.PublicKey(\n  'AGydXrbh2V9RH3h3cDzpws51tRDs2HbTtUXnCkq58bwH',\n);\n\ninterface MagicHatState {\n  itemsAvailable: number;\n  itemsRedeemed: number;\n  itemsRemaining: number;\n  treasury: anchor.web3.PublicKey;\n  tokenMint: anchor.web3.PublicKey;\n  isSoldOut: boolean;\n  isActive: boolean;\n  isPresale: boolean;\n  goLiveDate: anchor.BN;\n  price: anchor.BN;\n  gatekeeper: null | {\n    expireOnUse: boolean;\n    gatekeeperNetwork: anchor.web3.PublicKey;\n  };\n  endSettings: null | {\n    number: anchor.BN;\n    endSettingType: any;\n  };\n  whitelistMintSettings: null | {\n    mode: any;\n    mint: anchor.web3.PublicKey;\n    presale: boolean;\n    discountPrice: null | anchor.BN;\n  };\n  hiddenSettings: null | {\n    name: string;\n    uri: string;\n    hash: Uint8Array;\n  };\n}\n\nexport interface MagicHatAccount {\n  id: anchor.web3.PublicKey;\n  program: anchor.Program;\n  state: MagicHatState;\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  queryStatus = false,\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection && connection._signatureSubscriptions && connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log('Returning status', status);\n  return status;\n};\n\nconst createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\nexport const getMagicHatState = async (\n  anchorWallet: anchor.Wallet,\n  magicHatId: anchor.web3.PublicKey,\n  connection: anchor.web3.Connection,\n): Promise<MagicHatAccount> => {\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'recent',\n  });\n\n  const idl:any = idlMagicHat;\n\n  const program = new anchor.Program(idl, MAGIC_HAT_PROGRAM_V2_ID, provider);\n\n  const state: any = await program.account.magicHat.fetch(magicHatId);\n  console.log(state.authority.toBase58());\n  const itemsAvailable = state.data.itemsAvailable.toNumber();\n  const itemsRedeemed = state.itemsRedeemed.toNumber();\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n  const presale =\n    state.data.whitelistMintSettings &&\n    state.data.whitelistMintSettings.presale &&\n    (!state.data.goLiveDate ||\n      state.data.goLiveDate.toNumber() > new Date().getTime() / 1000);\n\n  return {\n    id: magicHatId,\n    program,\n    state: {\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      isSoldOut: itemsRemaining === 0,\n      isActive:\n        (presale ||\n          state.data.goLiveDate?.toNumber() < new Date().getTime() / 1000) &&\n        (state.data.endSettings\n          ? state.data.endSettings.endSettingType.date\n            ? state.data.endSettings.number.toNumber() >\n              new Date().getTime() / 1000\n            : itemsRedeemed < state.data.endSettings.number.toNumber()\n          : true),\n      isPresale: presale,\n      goLiveDate: state.data.goLiveDate,\n      treasury: state.wallet,\n      tokenMint: state.tokenMint,\n      gatekeeper: state.data.gatekeeper,\n      endSettings: state.data.endSettings,\n      whitelistMintSettings: state.data.whitelistMintSettings,\n      hiddenSettings: state.data.hiddenSettings,\n      price: state.data.price,\n    },\n  };\n};\n\nconst getMasterEdition = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getMagicHatCreator = async (\n  magicHat: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from('magic_hat'), magicHat.toBuffer()],\n    MAGIC_HAT_PROGRAM_V2_ID,\n  );\n};\n\nexport const mintOneToken = async (\n  magicHat: MagicHatAccount,\n  payer: anchor.web3.PublicKey,\n  wallet: any,\n  id:any\n): Promise<(string | undefined)[]> => {\n  const mint = anchor.web3.Keypair.generate();\n\n  const userTokenAccountAddress = (\n    await getAtaForMint(mint.publicKey, payer)\n  )[0];\n\n  const userPayingAccountAddress = magicHat.state.tokenMint\n    ? (await getAtaForMint(magicHat.state.tokenMint, payer))[0]\n    : payer;\n\n  const MAGIC_HAT_ID = magicHat.id;\n  console.log(MAGIC_HAT_ID.toBase58());\n  const remainingAccounts = [];\n  const signers: anchor.web3.Keypair[] = [mint];\n  const cleanupInstructions = [];\n  const instructions  = [\n    anchor.web3.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: mint.publicKey,\n      space: MintLayout.span,\n      lamports:\n        await magicHat.program.provider.connection.getMinimumBalanceForRentExemption(\n          MintLayout.span,\n        ),\n      programId: TOKEN_PROGRAM_ID,\n    }),\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      0,\n      payer,\n      payer,\n    ),\n    createAssociatedTokenAccountInstruction(\n      userTokenAccountAddress,\n      payer,\n      payer,\n      mint.publicKey,\n    ),\n    Token.createMintToInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      userTokenAccountAddress,\n      payer,\n      [],\n      1,\n    )\n  ];\n\n  if (magicHat.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (\n        await getNetworkToken(\n          payer,\n          magicHat.state.gatekeeper.gatekeeperNetwork,\n        )\n      )[0],\n      isWritable: true,\n      isSigner: false,\n    });\n    if (magicHat.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkExpire(\n            magicHat.state.gatekeeper.gatekeeperNetwork,\n          )\n        )[0],\n        isWritable: false,\n        isSigner: false,\n      });\n    }\n  }\n  if (magicHat.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(\n      magicHat.state.whitelistMintSettings.mint,\n    );\n\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (magicHat.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists =\n        await magicHat.program.provider.connection.getAccountInfo(\n          whitelistToken,\n        );\n      if (exists) {\n        instructions.push(\n          Token.createApproveInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            whitelistBurnAuthority.publicKey,\n            payer,\n            [],\n            1,\n          ),\n        );\n        cleanupInstructions.push(\n          Token.createRevokeInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            payer,\n            [],\n          ),\n        );\n      }\n    }\n  }\n\n  if (magicHat.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n    for (let index = 0; index < remainingAccounts.length; index++) {\n      let element = remainingAccounts[index];\n      if (element.pubkey === userPayingAccountAddress) {\n        console.log('Already Minted !!!')\n      }\n    }\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false,\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true,\n    });\n\n    instructions.push(\n      Token.createApproveInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        transferAuthority.publicKey,\n        payer,\n        [],\n        magicHat.state.price.toNumber(),\n      ),\n    );\n    cleanupInstructions.push(\n      Token.createRevokeInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        payer,\n        [],\n      ),\n    );\n  }\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const [magicHatCreator, creatorBump] = await getMagicHatCreator(\n    MAGIC_HAT_ID,\n  );\n\n  instructions.push(\n    await magicHat.program.instruction.mintNft(creatorBump, {\n      accounts: {\n        magicHat: MAGIC_HAT_ID,\n        magicHatCreator,\n        payer: payer,\n        wallet: magicHat.state.treasury,\n        metadata: metadataAddress,\n        mint: mint.publicKey,\n        mintAuthority: payer,\n        updateAuthority: payer,\n        masterEdition,\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n        rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n        recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n      },\n      remainingAccounts:\n        remainingAccounts.length > 0 ? remainingAccounts : undefined,\n    }),\n  );\n  try {\n    return (\n      await sendTransactions(\n        magicHat.program.provider.connection,\n        magicHat.program.provider.wallet,\n        [instructions, cleanupInstructions],\n        [signers, []],\n      )\n    ).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\n\nexport const mintOneTokenWL = async (\n  magicHat: MagicHatAccount,\n  payer: anchor.web3.PublicKey,\n  wallet_pda: any\n): Promise<(string | undefined)[]> => {\n  const mint = anchor.web3.Keypair.generate();\n\n  const userTokenAccountAddress = (\n    await getAtaForMint(mint.publicKey, payer)\n  )[0];\n\n  const userPayingAccountAddress = magicHat.state.tokenMint\n    ? (await getAtaForMint(magicHat.state.tokenMint, payer))[0]\n    : payer;\n  const remainingAccounts = [];\n  const signers: anchor.web3.Keypair[] = [mint];\n  const cleanupInstructions = [];\n  const instructions  = [\n    anchor.web3.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: mint.publicKey,\n      space: MintLayout.span,\n      lamports:\n        await magicHat.program.provider.connection.getMinimumBalanceForRentExemption(\n          MintLayout.span,\n        ),\n      programId: TOKEN_PROGRAM_ID,\n    }),\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      0,\n      payer,\n      payer,\n    ),\n    createAssociatedTokenAccountInstruction(\n      userTokenAccountAddress,\n      payer,\n      payer,\n      mint.publicKey,\n    ),\n    Token.createMintToInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      userTokenAccountAddress,\n      payer,\n      [],\n      1,\n    )\n  ];\n\n  if (magicHat.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (\n        await getNetworkToken(\n          payer,\n          magicHat.state.gatekeeper.gatekeeperNetwork,\n        )\n      )[0],\n      isWritable: true,\n      isSigner: false,\n    });\n    if (magicHat.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkExpire(\n            magicHat.state.gatekeeper.gatekeeperNetwork,\n          )\n        )[0],\n        isWritable: false,\n        isSigner: false,\n      });\n    }\n  }\n  if (magicHat.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(\n      magicHat.state.whitelistMintSettings.mint,\n    );\n\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (magicHat.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists =\n        await magicHat.program.provider.connection.getAccountInfo(\n          whitelistToken,\n        );\n      if (exists) {\n        instructions.push(\n          Token.createApproveInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            whitelistBurnAuthority.publicKey,\n            payer,\n            [],\n            1,\n          ),\n        );\n        cleanupInstructions.push(\n          Token.createRevokeInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            payer,\n            [],\n          ),\n        );\n      }\n    }\n  }\n\n  if (magicHat.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n    for (let index = 0; index < remainingAccounts.length; index++) {\n      let element = remainingAccounts[index];\n      if (element.pubkey === userPayingAccountAddress) {\n        console.log('Already Minted !!!')\n      }\n    }\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false,\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true,\n    });\n\n    instructions.push(\n      Token.createApproveInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        transferAuthority.publicKey,\n        payer,\n        [],\n        magicHat.state.price.toNumber(),\n      ),\n    );\n    cleanupInstructions.push(\n      Token.createRevokeInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        payer,\n        [],\n      ),\n    );\n  }\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const [magicHatCreator, creatorBump] = await getMagicHatCreator(\n    MAGIC_HAT_ID,\n  );\n  console.log(MAGIC_HAT_ID.toBase58());\n  instructions.push(\n    await magicHat.program.instruction.wlMintNft(creatorBump, {\n      accounts: {\n        magicHat: MAGIC_HAT_ID,\n        walletWhitelist: wallet_pda,\n        magicHatCreator: magicHatCreator,\n        whitelistedAddress: payer,\n        wallet: magicHat.state.treasury,\n        metadata: metadataAddress,\n        mint: mint.publicKey,\n        mintAuthority: payer,\n        updateAuthority: payer,\n        masterEdition,\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n        rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n        recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n      },\n      remainingAccounts:\n        remainingAccounts.length > 0 ? remainingAccounts : undefined,\n    }),\n  );\n  try {\n    return (\n      await sendTransactions(\n        magicHat.program.provider.connection,\n        magicHat.program.provider.wallet,\n        [instructions, cleanupInstructions],\n        [signers, []],\n      )\n    ).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}