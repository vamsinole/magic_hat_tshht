{"ast":null,"code":"\"use strict\";\n\nfunction compile(nodes) {\n  var assignedPaths = [];\n  var valueAssignments = [];\n  var currentPath = \"\";\n  var data = Object.create(null);\n  var context = data;\n  var arrayMode = false;\n  return reduce(nodes);\n\n  function reduce(nodes) {\n    var node;\n\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n\n      switch (node.type) {\n        case \"Assign\":\n          assign(node);\n          break;\n\n        case \"ObjectPath\":\n          setPath(node);\n          break;\n\n        case \"ArrayPath\":\n          addTableArray(node);\n          break;\n      }\n    }\n\n    return data;\n  }\n\n  function genError(err, line, col) {\n    var ex = new Error(err);\n    ex.line = line;\n    ex.column = col;\n    throw ex;\n  }\n\n  function assign(node) {\n    var key = node.key;\n    var value = node.value;\n    var line = node.line;\n    var column = node.column;\n    var fullPath;\n\n    if (currentPath) {\n      fullPath = currentPath + \".\" + key;\n    } else {\n      fullPath = key;\n    }\n\n    if (typeof context[key] !== \"undefined\") {\n      genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\n    }\n\n    context[key] = reduceValueNode(value);\n\n    if (!pathAssigned(fullPath)) {\n      assignedPaths.push(fullPath);\n      valueAssignments.push(fullPath);\n    }\n  }\n\n  function pathAssigned(path) {\n    return assignedPaths.indexOf(path) !== -1;\n  }\n\n  function reduceValueNode(node) {\n    if (node.type === \"Array\") {\n      return reduceArrayWithTypeChecking(node.value);\n    } else if (node.type === \"InlineTable\") {\n      return reduceInlineTableNode(node.value);\n    } else {\n      return node.value;\n    }\n  }\n\n  function reduceInlineTableNode(values) {\n    var obj = Object.create(null);\n\n    for (var i = 0; i < values.length; i++) {\n      var val = values[i];\n\n      if (val.value.type === \"InlineTable\") {\n        obj[val.key] = reduceInlineTableNode(val.value.value);\n      } else if (val.type === \"InlineTableValue\") {\n        obj[val.key] = reduceValueNode(val.value);\n      }\n    }\n\n    return obj;\n  }\n\n  function setPath(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (pathAssigned(quotedPath)) {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, Object.create(null), line, column);\n    currentPath = path;\n  }\n\n  function addTableArray(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (!pathAssigned(quotedPath)) {\n      assignedPaths.push(quotedPath);\n    }\n\n    assignedPaths = assignedPaths.filter(function (p) {\n      return p.indexOf(quotedPath) !== 0;\n    });\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, [], line, column);\n    currentPath = quotedPath;\n\n    if (context instanceof Array) {\n      var newObj = Object.create(null);\n      context.push(newObj);\n      context = newObj;\n    } else {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n  } // Given a path 'a.b.c', create (as necessary) `start.a`,\n  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\n  // If `a` or `b` are arrays and have items in them, the last item in the\n  // array is used as the context for the next sub-path.\n\n\n  function deepRef(start, keys, value, line, column) {\n    var traversed = [];\n    var traversedPath = \"\";\n    var path = keys.join(\".\");\n    var ctx = start;\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      traversed.push(key);\n      traversedPath = traversed.join(\".\");\n\n      if (typeof ctx[key] === \"undefined\") {\n        if (i === keys.length - 1) {\n          ctx[key] = value;\n        } else {\n          ctx[key] = Object.create(null);\n        }\n      } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {\n        // already a non-object value at key, can't be used as part of a new path\n        genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\n      }\n\n      ctx = ctx[key];\n\n      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {\n        ctx = ctx[ctx.length - 1];\n      }\n    }\n\n    return ctx;\n  }\n\n  function reduceArrayWithTypeChecking(array) {\n    // Ensure that all items in the array are of the same type\n    var firstType = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var node = array[i];\n\n      if (firstType === null) {\n        firstType = node.type;\n      } else {\n        if (node.type !== firstType) {\n          genError(\"Cannot add value of type \" + node.type + \" to array of type \" + firstType + \".\", node.line, node.column);\n        }\n      }\n    } // Recursively reduce array of nodes into array of the nodes' values\n\n\n    return array.map(reduceValueNode);\n  }\n\n  function quoteDottedString(str) {\n    if (str.indexOf(\".\") > -1) {\n      return \"\\\"\" + str + \"\\\"\";\n    } else {\n      return str;\n    }\n  }\n}\n\nmodule.exports = {\n  compile: compile\n};","map":{"version":3,"names":["compile","nodes","assignedPaths","valueAssignments","currentPath","data","Object","create","context","arrayMode","reduce","node","i","length","type","assign","setPath","addTableArray","genError","err","line","col","ex","Error","column","key","value","fullPath","reduceValueNode","pathAssigned","push","path","indexOf","reduceArrayWithTypeChecking","reduceInlineTableNode","values","obj","val","quotedPath","map","quoteDottedString","join","deepRef","filter","p","Array","newObj","start","keys","traversed","traversedPath","ctx","array","firstType","str","module","exports"],"sources":["/Users/vamshikrishnaenjapuri/magic_hat_ui/node_modules/toml/lib/compiler.js"],"sourcesContent":["\"use strict\";\nfunction compile(nodes) {\n  var assignedPaths = [];\n  var valueAssignments = [];\n  var currentPath = \"\";\n  var data = Object.create(null);\n  var context = data;\n  var arrayMode = false;\n\n  return reduce(nodes);\n\n  function reduce(nodes) {\n    var node;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      switch (node.type) {\n      case \"Assign\":\n        assign(node);\n        break;\n      case \"ObjectPath\":\n        setPath(node);\n        break;\n      case \"ArrayPath\":\n        addTableArray(node);\n        break;\n      }\n    }\n\n    return data;\n  }\n\n  function genError(err, line, col) {\n    var ex = new Error(err);\n    ex.line = line;\n    ex.column = col;\n    throw ex;\n  }\n\n  function assign(node) {\n    var key = node.key;\n    var value = node.value;\n    var line = node.line;\n    var column = node.column;\n\n    var fullPath;\n    if (currentPath) {\n      fullPath = currentPath + \".\" + key;\n    } else {\n      fullPath = key;\n    }\n    if (typeof context[key] !== \"undefined\") {\n      genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\n    }\n\n    context[key] = reduceValueNode(value);\n\n    if (!pathAssigned(fullPath)) {\n      assignedPaths.push(fullPath);\n      valueAssignments.push(fullPath);\n    }\n  }\n\n\n  function pathAssigned(path) {\n    return assignedPaths.indexOf(path) !== -1;\n  }\n\n  function reduceValueNode(node) {\n    if (node.type === \"Array\") {\n      return reduceArrayWithTypeChecking(node.value);\n    } else if (node.type === \"InlineTable\") {\n      return reduceInlineTableNode(node.value);\n    } else {\n      return node.value;\n    }\n  }\n\n  function reduceInlineTableNode(values) {\n    var obj = Object.create(null);\n    for (var i = 0; i < values.length; i++) {\n      var val = values[i];\n      if (val.value.type === \"InlineTable\") {\n        obj[val.key] = reduceInlineTableNode(val.value.value);\n      } else if (val.type === \"InlineTableValue\") {\n        obj[val.key] = reduceValueNode(val.value);\n      }\n    }\n\n    return obj;\n  }\n\n  function setPath(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (pathAssigned(quotedPath)) {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, Object.create(null), line, column);\n    currentPath = path;\n  }\n\n  function addTableArray(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (!pathAssigned(quotedPath)) {\n      assignedPaths.push(quotedPath);\n    }\n    assignedPaths = assignedPaths.filter(function(p) {\n      return p.indexOf(quotedPath) !== 0;\n    });\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, [], line, column);\n    currentPath = quotedPath;\n\n    if (context instanceof Array) {\n      var newObj = Object.create(null);\n      context.push(newObj);\n      context = newObj;\n    } else {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n  }\n\n  // Given a path 'a.b.c', create (as necessary) `start.a`,\n  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\n  // If `a` or `b` are arrays and have items in them, the last item in the\n  // array is used as the context for the next sub-path.\n  function deepRef(start, keys, value, line, column) {\n    var traversed = [];\n    var traversedPath = \"\";\n    var path = keys.join(\".\");\n    var ctx = start;\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      traversed.push(key);\n      traversedPath = traversed.join(\".\");\n      if (typeof ctx[key] === \"undefined\") {\n        if (i === keys.length - 1) {\n          ctx[key] = value;\n        } else {\n          ctx[key] = Object.create(null);\n        }\n      } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {\n        // already a non-object value at key, can't be used as part of a new path\n        genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\n      }\n\n      ctx = ctx[key];\n      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {\n        ctx = ctx[ctx.length - 1];\n      }\n    }\n\n    return ctx;\n  }\n\n  function reduceArrayWithTypeChecking(array) {\n    // Ensure that all items in the array are of the same type\n    var firstType = null;\n    for (var i = 0; i < array.length; i++) {\n      var node = array[i];\n      if (firstType === null) {\n        firstType = node.type;\n      } else {\n        if (node.type !== firstType) {\n          genError(\"Cannot add value of type \" + node.type + \" to array of type \" +\n            firstType + \".\", node.line, node.column);\n        }\n      }\n    }\n\n    // Recursively reduce array of nodes into array of the nodes' values\n    return array.map(reduceValueNode);\n  }\n\n  function quoteDottedString(str) {\n    if (str.indexOf(\".\") > -1) {\n      return \"\\\"\" + str + \"\\\"\";\n    } else {\n      return str;\n    }\n  }\n}\n\nmodule.exports = {\n  compile: compile\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}