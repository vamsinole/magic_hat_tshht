{"ast":null,"code":"var SemVer = require('../classes/semver');\n\nvar parse = require('./parse');\n\nvar _require = require('../internal/re'),\n    re = _require.re,\n    t = _require.t;\n\nvar coerce = function coerce(version, options) {\n  if (version instanceof SemVer) {\n    return version;\n  }\n\n  if (typeof version === 'number') {\n    version = String(version);\n  }\n\n  if (typeof version !== 'string') {\n    return null;\n  }\n\n  options = options || {};\n  var match = null;\n\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE]);\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    var next;\n\n    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n      if (!match || next.index + next[0].length !== match.index + match[0].length) {\n        match = next;\n      }\n\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;\n    } // leave it in a clean state\n\n\n    re[t.COERCERTL].lastIndex = -1;\n  }\n\n  if (match === null) return null;\n  return parse(\"\".concat(match[2], \".\").concat(match[3] || '0', \".\").concat(match[4] || '0'), options);\n};\n\nmodule.exports = coerce;","map":{"version":3,"names":["SemVer","require","parse","re","t","coerce","version","options","String","match","rtl","COERCE","next","COERCERTL","exec","index","length","lastIndex","module","exports"],"sources":["/Users/vamshikrishnaenjapuri/Documents/secretalpha/node_modules/semver/functions/coerce.js"],"sourcesContent":["const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst {re, t} = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n"],"mappings":"AAAA,IAAMA,MAAM,GAAGC,OAAO,CAAC,mBAAD,CAAtB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAArB;;AACA,eAAgBA,OAAO,CAAC,gBAAD,CAAvB;AAAA,IAAOE,EAAP,YAAOA,EAAP;AAAA,IAAWC,CAAX,YAAWA,CAAX;;AAEA,IAAMC,MAAM,GAAG,SAATA,MAAS,CAACC,OAAD,EAAUC,OAAV,EAAsB;EACnC,IAAID,OAAO,YAAYN,MAAvB,EAA+B;IAC7B,OAAOM,OAAP;EACD;;EAED,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;IAC/BA,OAAO,GAAGE,MAAM,CAACF,OAAD,CAAhB;EACD;;EAED,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;IAC/B,OAAO,IAAP;EACD;;EAEDC,OAAO,GAAGA,OAAO,IAAI,EAArB;EAEA,IAAIE,KAAK,GAAG,IAAZ;;EACA,IAAI,CAACF,OAAO,CAACG,GAAb,EAAkB;IAChBD,KAAK,GAAGH,OAAO,CAACG,KAAR,CAAcN,EAAE,CAACC,CAAC,CAACO,MAAH,CAAhB,CAAR;EACD,CAFD,MAEO;IACL;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIC,IAAJ;;IACA,OAAO,CAACA,IAAI,GAAGT,EAAE,CAACC,CAAC,CAACS,SAAH,CAAF,CAAgBC,IAAhB,CAAqBR,OAArB,CAAR,MACF,CAACG,KAAD,IAAUA,KAAK,CAACM,KAAN,GAAcN,KAAK,CAAC,CAAD,CAAL,CAASO,MAAvB,KAAkCV,OAAO,CAACU,MADlD,CAAP,EAEE;MACA,IAAI,CAACP,KAAD,IACEG,IAAI,CAACG,KAAL,GAAaH,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAArB,KAAgCP,KAAK,CAACM,KAAN,GAAcN,KAAK,CAAC,CAAD,CAAL,CAASO,MAD7D,EACqE;QACnEP,KAAK,GAAGG,IAAR;MACD;;MACDT,EAAE,CAACC,CAAC,CAACS,SAAH,CAAF,CAAgBI,SAAhB,GAA4BL,IAAI,CAACG,KAAL,GAAaH,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAArB,GAA8BJ,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAAlE;IACD,CAlBI,CAmBL;;;IACAb,EAAE,CAACC,CAAC,CAACS,SAAH,CAAF,CAAgBI,SAAhB,GAA4B,CAAC,CAA7B;EACD;;EAED,IAAIR,KAAK,KAAK,IAAd,EACE,OAAO,IAAP;EAEF,OAAOP,KAAK,WAAIO,KAAK,CAAC,CAAD,CAAT,cAAgBA,KAAK,CAAC,CAAD,CAAL,IAAY,GAA5B,cAAmCA,KAAK,CAAC,CAAD,CAAL,IAAY,GAA/C,GAAsDF,OAAtD,CAAZ;AACD,CA7CD;;AA8CAW,MAAM,CAACC,OAAP,GAAiBd,MAAjB"},"metadata":{},"sourceType":"script"}