{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _arrayPrototype = _interopRequireDefault(require(\"array.prototype.find\"));\n\nvar _getComponentName = _interopRequireDefault(require(\"./helpers/getComponentName\"));\n\nvar _renderableChildren = _interopRequireDefault(require(\"./helpers/renderableChildren\"));\n\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction onlyTypes(types, children, componentName) {\n  if (!children.every(function (child) {\n    return child && (0, _arrayPrototype[\"default\"])(types, function (Type) {\n      return Type === '*' || child.type === Type;\n    });\n  })) {\n    var typeNames = types.map(_getComponentName[\"default\"]).join(', or ');\n    return new TypeError(\"`\".concat(componentName, \"` only accepts children of type \").concat(typeNames));\n  }\n\n  return null;\n}\n\nfunction isRequired(types, children, componentName) {\n  if (children.length === 0) {\n    var typeNames = types.map(_getComponentName[\"default\"]).join(', or ');\n    return new TypeError(\"`\".concat(componentName, \"` requires at least one node of type \").concat(typeNames));\n  }\n\n  return null;\n}\n\nfunction childrenOfType() {\n  for (var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++) {\n    types[_key] = arguments[_key];\n  }\n\n  if (types.length < 1) {\n    throw new TypeError('childrenOfType: at least 1 type is required');\n  }\n\n  function validator(props, propName, componentName) {\n    return onlyTypes(types, (0, _renderableChildren[\"default\"])(props[propName]), componentName);\n  }\n\n  validator.isRequired = function (props, propName, componentName) {\n    var children = (0, _renderableChildren[\"default\"])(props[propName]);\n    return isRequired(types, children, componentName) || onlyTypes(types, children, componentName);\n  };\n\n  return (0, _wrapValidator[\"default\"])(validator, 'childrenOfType', types);\n}\n\nvar _default = childrenOfType;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;;;;;;;AAEA,SAASA,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,aAApC,EAAmD;EACjD,IAAI,CAACD,QAAQ,CAACE,KAATF,CAAe,UAACG,KAAD;IAAA,OAAWA,KAAK,IAAI,gCAAKJ,KAAL,EAAY,UAACK,IAAD;MAAA,OAAUA,IAAI,KAAK,GAATA,IAAgBD,KAAK,CAACE,IAANF,KAAeC,IAAzC;IAAZ,EAApB;EAAf,EAAL,EAAqG;IACnG,IAAME,SAAS,GAAGP,KAAK,CAACQ,GAANR,CAAUS,4BAAVT,EAA4BU,IAA5BV,CAAiC,OAAjCA,CAAlB;IACA,OAAO,IAAIW,SAAJ,YACAT,aADA,6CACiDK,SADjD,EAAP;EAGD;;EACD,OAAO,IAAP;AACD;;AAED,SAASK,UAAT,CAAoBZ,KAApB,EAA2BC,QAA3B,EAAqCC,aAArC,EAAoD;EAClD,IAAID,QAAQ,CAACY,MAATZ,KAAoB,CAAxB,EAA2B;IACzB,IAAMM,SAAS,GAAGP,KAAK,CAACQ,GAANR,CAAUS,4BAAVT,EAA4BU,IAA5BV,CAAiC,OAAjCA,CAAlB;IACA,OAAO,IAAIW,SAAJ,YAAmBT,aAAnB,kDAAyEK,SAAzE,EAAP;EACD;;EACD,OAAO,IAAP;AACD;;AAED,SAASO,cAAT,GAAkC;EAAA,kCAAPd,KAAO;IAAPA,KAAO,MAAPA,GAAOe,eAAPf;EAAO;;EAChC,IAAIA,KAAK,CAACa,MAANb,GAAe,CAAnB,EAAsB;IACpB,MAAM,IAAIW,SAAJ,CAAc,6CAAd,CAAN;EACD;;EAED,SAASK,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoChB,aAApC,EAAmD;IACjD,OAAOH,SAAS,CAACC,KAAD,EAAQ,oCAAmBiB,KAAK,CAACC,QAAD,CAAxB,CAAR,EAA6ChB,aAA7C,CAAhB;EACD;;EAEDc,SAAS,CAACJ,UAAVI,GAAuB,UAACC,KAAD,EAAQC,QAAR,EAAkBhB,aAAlB,EAAoC;IACzD,IAAMD,QAAQ,GAAG,oCAAmBgB,KAAK,CAACC,QAAD,CAAxB,CAAjB;IACA,OAAON,UAAU,CAACZ,KAAD,EAAQC,QAAR,EAAkBC,aAAlB,CAAVU,IAA8Cb,SAAS,CAACC,KAAD,EAAQC,QAAR,EAAkBC,aAAlB,CAA9D;EAFF;;EAKA,OAAO,+BAAcc,SAAd,EAAyB,gBAAzB,EAA2ChB,KAA3C,CAAP;AACD;;eAEcc","names":["onlyTypes","types","children","componentName","every","child","Type","type","typeNames","map","getComponentName","join","TypeError","isRequired","length","childrenOfType","arguments","validator","props","propName"],"sources":["../src/childrenOfType.js"],"sourcesContent":["import find from 'array.prototype.find';\n\nimport getComponentName from './helpers/getComponentName';\nimport renderableChildren from './helpers/renderableChildren';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction onlyTypes(types, children, componentName) {\n  if (!children.every((child) => child && find(types, (Type) => Type === '*' || child.type === Type))) {\n    const typeNames = types.map(getComponentName).join(', or ');\n    return new TypeError(\n      `\\`${componentName}\\` only accepts children of type ${typeNames}`,\n    );\n  }\n  return null;\n}\n\nfunction isRequired(types, children, componentName) {\n  if (children.length === 0) {\n    const typeNames = types.map(getComponentName).join(', or ');\n    return new TypeError(`\\`${componentName}\\` requires at least one node of type ${typeNames}`);\n  }\n  return null;\n}\n\nfunction childrenOfType(...types) {\n  if (types.length < 1) {\n    throw new TypeError('childrenOfType: at least 1 type is required');\n  }\n\n  function validator(props, propName, componentName) {\n    return onlyTypes(types, renderableChildren(props[propName]), componentName);\n  }\n\n  validator.isRequired = (props, propName, componentName) => {\n    const children = renderableChildren(props[propName]);\n    return isRequired(types, children, componentName) || onlyTypes(types, children, componentName);\n  };\n\n  return wrapValidator(validator, 'childrenOfType', types);\n}\n\nexport default childrenOfType;\n"]},"metadata":{},"sourceType":"script"}