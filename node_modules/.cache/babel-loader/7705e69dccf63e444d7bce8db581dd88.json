{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = sequenceOfValidator;\n\nvar _propTypes = require(\"prop-types\");\n\nvar _and = _interopRequireDefault(require(\"./and\"));\n\nvar _between = _interopRequireDefault(require(\"./between\"));\n\nvar _nonNegativeInteger = _interopRequireDefault(require(\"./nonNegativeInteger\"));\n\nvar _object = _interopRequireDefault(require(\"./object\"));\n\nvar _withShape = _interopRequireDefault(require(\"./withShape\"));\n\nvar _typeOf = _interopRequireDefault(require(\"./helpers/typeOf\"));\n\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar minValidator = _nonNegativeInteger[\"default\"];\nvar maxValidator = (0, _and[\"default\"])([_nonNegativeInteger[\"default\"], (0, _between[\"default\"])({\n  gte: 1\n})]);\n\nfunction validateRange(min, max) {\n  if (typeof max !== 'number' || typeof min !== 'number') {\n    return null; // no additional checking needed unless both are present\n  }\n\n  if (min <= max) {\n    return null;\n  }\n\n  return new RangeError('min must be less than or equal to max');\n}\n\nvar specifierShape = {\n  validator: function validator(props, propName) {\n    var propValue = props[propName];\n\n    if (typeof propValue !== 'function') {\n      return new TypeError('\"validator\" must be a propType validator function');\n    }\n\n    return null;\n  },\n  min: function min(props, propName) {\n    return minValidator(props, propName) || validateRange(props.min, props.max);\n  },\n  max: function max(props, propName) {\n    return maxValidator(props, propName) || validateRange(props.min, props.max);\n  }\n};\n\nfunction getMinMax(_ref) {\n  var min = _ref.min,\n      max = _ref.max;\n  var minimum;\n  var maximum;\n\n  if (typeof min !== 'number' && typeof max !== 'number') {\n    // neither provided, default to \"1\"\n    minimum = 1;\n    maximum = 1;\n  } else {\n    minimum = typeof min === 'number' ? min : 1;\n    maximum = typeof max === 'number' ? max : Infinity;\n  }\n\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}\n\nfunction chunkByType(items) {\n  var chunk = [];\n  var lastType;\n  return items.reduce(function (chunks, item) {\n    var itemType = (0, _typeOf[\"default\"])(item);\n\n    if (!lastType || itemType === lastType) {\n      chunk.push(item);\n    } else {\n      chunks.push(chunk);\n      chunk = [item];\n    }\n\n    lastType = itemType;\n    return chunks;\n  }, []).concat(chunk.length > 0 ? [chunk] : []);\n}\n\nfunction validateChunks(specifiers, props, propName, componentName) {\n  var items = props[propName];\n  var chunks = chunkByType(items);\n\n  for (var _len = arguments.length, rest = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n    rest[_key - 4] = arguments[_key];\n  }\n\n  for (var i = 0; i < specifiers.length; i += 1) {\n    var _specifiers$i = specifiers[i],\n        validator = _specifiers$i.validator,\n        min = _specifiers$i.min,\n        max = _specifiers$i.max;\n\n    var _getMinMax = getMinMax({\n      min: min,\n      max: max\n    }),\n        minimum = _getMinMax.minimum,\n        maximum = _getMinMax.maximum;\n\n    if (chunks.length === 0 && minimum === 0) {\n      // no chunks left, but this specifier does not require any items\n      continue; // eslint-disable-line no-continue\n    }\n\n    var arrayOfValidator = (0, _propTypes.arrayOf)(validator).isRequired;\n    var chunk = chunks.shift(); // extract the next chunk to test\n\n    var chunkError = arrayOfValidator.apply(void 0, [_objectSpread(_objectSpread({}, props), {}, _defineProperty({}, propName, chunk)), propName, componentName].concat(rest));\n\n    if (chunkError) {\n      // this chunk is invalid\n      if (minimum === 0) {\n        // but, specifier has a min of 0 and can be skipped\n        chunks.unshift(chunk); // put the chunk back, for the next iteration\n\n        continue; // eslint-disable-line no-continue\n      }\n\n      return chunkError;\n    } // chunk is valid!\n\n\n    if (chunk.length < minimum) {\n      return new RangeError(\"\".concat(componentName, \": specifier index \").concat(i, \" requires a minimum of \").concat(min, \" items, but only has \").concat(chunk.length, \".\"));\n    }\n\n    if (chunk.length > maximum) {\n      return new RangeError(\"\".concat(componentName, \": specifier index \").concat(i, \" requires a maximum of \").concat(max, \" items, but has \").concat(chunk.length, \".\"));\n    }\n  }\n\n  if (chunks.length > 0) {\n    return new TypeError(\"\".concat(componentName, \": after all \").concat(specifiers.length, \" specifiers matched, \").concat(chunks.length, \" types of items were remaining.\"));\n  }\n\n  return null;\n}\n\nvar specifierValidator = (0, _withShape[\"default\"])((0, _object[\"default\"])(), specifierShape).isRequired;\n\nfunction sequenceOfValidator() {\n  for (var _len2 = arguments.length, specifiers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    specifiers[_key2] = arguments[_key2];\n  }\n\n  if (specifiers.length === 0) {\n    throw new RangeError('sequenceOf: at least one specifier is required');\n  }\n\n  var errors = specifiers.map(function (specifier, i) {\n    return specifierValidator({\n      specifier: specifier\n    }, 'specifier', 'sequenceOf specifier', \"suequenceOf specifier, index \".concat(i), \"specifier, index \".concat(i));\n  });\n\n  if (errors.some(Boolean)) {\n    throw new TypeError(\"\\n      sequenceOf: all specifiers must match the appropriate shape.\\n\\n      Errors:\\n        \".concat(errors.map(function (e, i) {\n      return \" - Argument index \".concat(i, \": \").concat(e.message);\n    }).join(',\\n        '), \"\\n    \"));\n  }\n\n  var validator = function sequenceOf(props, propName) {\n    var propValue = props[propName];\n\n    if (propValue == null) {\n      return null;\n    }\n\n    for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      rest[_key3 - 2] = arguments[_key3];\n    }\n\n    var error = _propTypes.array.apply(void 0, [props, propName].concat(rest));\n\n    if (error) {\n      return error;\n    }\n\n    return validateChunks.apply(void 0, [specifiers, props, propName].concat(rest));\n  };\n\n  validator.isRequired = function sequenceOfRequired(props, propName, componentName) {\n    for (var _len4 = arguments.length, rest = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n      rest[_key4 - 3] = arguments[_key4];\n    }\n\n    var error = _propTypes.array.isRequired.apply(_propTypes.array, [props, propName, componentName].concat(rest));\n\n    if (error) {\n      return error;\n    }\n\n    return validateChunks.apply(void 0, [specifiers, props, propName, componentName].concat(rest));\n  };\n\n  return (0, _wrapValidator[\"default\"])(validator, 'sequenceOf', specifiers);\n}","map":{"version":3,"mappings":"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","names":["minValidator","nonNegativeInteger","maxValidator","gte","validateRange","min","max","RangeError","specifierShape","validator","props","propName","propValue","TypeError","getMinMax","minimum","maximum","Infinity","chunkByType","items","chunk","lastType","reduce","chunks","item","itemType","push","concat","length","validateChunks","specifiers","componentName","rest","arguments","i","arrayOfValidator","isRequired","shift","chunkError","unshift","specifierValidator","sequenceOfValidator","errors","map","specifier","some","Boolean","e","message","join","sequenceOf","error","array","sequenceOfRequired"],"sources":["../src/sequenceOf.js"],"sourcesContent":["import { array, arrayOf } from 'prop-types';\n\nimport and from './and';\nimport between from './between';\nimport nonNegativeInteger from './nonNegativeInteger';\nimport object from './object';\nimport withShape from './withShape';\nimport typeOf from './helpers/typeOf';\nimport wrapValidator from './helpers/wrapValidator';\n\nconst minValidator = nonNegativeInteger;\nconst maxValidator = and([nonNegativeInteger, between({ gte: 1 })]);\n\nfunction validateRange(min, max) {\n  if (typeof max !== 'number' || typeof min !== 'number') {\n    return null; // no additional checking needed unless both are present\n  }\n\n  if (min <= max) {\n    return null;\n  }\n  return new RangeError('min must be less than or equal to max');\n}\n\nconst specifierShape = {\n  validator(props, propName) {\n    const { [propName]: propValue } = props;\n    if (typeof propValue !== 'function') {\n      return new TypeError('\"validator\" must be a propType validator function');\n    }\n    return null;\n  },\n\n  min(props, propName) {\n    return minValidator(props, propName) || validateRange(props.min, props.max);\n  },\n\n  max(props, propName) {\n    return maxValidator(props, propName) || validateRange(props.min, props.max);\n  },\n};\n\nfunction getMinMax({ min, max }) {\n  let minimum;\n  let maximum;\n  if (typeof min !== 'number' && typeof max !== 'number') {\n    // neither provided, default to \"1\"\n    minimum = 1;\n    maximum = 1;\n  } else {\n    minimum = typeof min === 'number' ? min : 1;\n    maximum = typeof max === 'number' ? max : Infinity;\n  }\n  return { minimum, maximum };\n}\n\nfunction chunkByType(items) {\n  let chunk = [];\n  let lastType;\n  return items.reduce((chunks, item) => {\n    const itemType = typeOf(item);\n    if (!lastType || itemType === lastType) {\n      chunk.push(item);\n    } else {\n      chunks.push(chunk);\n      chunk = [item];\n    }\n    lastType = itemType;\n    return chunks;\n  }, []).concat(chunk.length > 0 ? [chunk] : []);\n}\n\nfunction validateChunks(specifiers, props, propName, componentName, ...rest) {\n  const { [propName]: items } = props;\n  const chunks = chunkByType(items);\n\n  for (let i = 0; i < specifiers.length; i += 1) {\n    const { validator, min, max } = specifiers[i];\n\n    const { minimum, maximum } = getMinMax({ min, max });\n\n    if (chunks.length === 0 && minimum === 0) {\n      // no chunks left, but this specifier does not require any items\n      continue; // eslint-disable-line no-continue\n    }\n\n    const arrayOfValidator = arrayOf(validator).isRequired;\n\n    const chunk = chunks.shift(); // extract the next chunk to test\n\n    const chunkError = arrayOfValidator(\n      { ...props, [propName]: chunk },\n      propName,\n      componentName,\n      ...rest,\n    );\n\n    if (chunkError) { // this chunk is invalid\n      if (minimum === 0) { // but, specifier has a min of 0 and can be skipped\n        chunks.unshift(chunk); // put the chunk back, for the next iteration\n        continue; // eslint-disable-line no-continue\n      }\n      return chunkError;\n    }\n\n    // chunk is valid!\n\n    if (chunk.length < minimum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a minimum of ${min} items, but only has ${chunk.length}.`);\n    }\n\n    if (chunk.length > maximum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a maximum of ${max} items, but has ${chunk.length}.`);\n    }\n  }\n\n  if (chunks.length > 0) {\n    return new TypeError(`${componentName}: after all ${specifiers.length} specifiers matched, ${chunks.length} types of items were remaining.`);\n  }\n\n  return null;\n}\n\nconst specifierValidator = withShape(object(), specifierShape).isRequired;\n\nexport default function sequenceOfValidator(...specifiers) {\n  if (specifiers.length === 0) {\n    throw new RangeError('sequenceOf: at least one specifier is required');\n  }\n\n  const errors = specifiers.map((specifier, i) => specifierValidator(\n    { specifier },\n    'specifier',\n    'sequenceOf specifier',\n    `suequenceOf specifier, index ${i}`,\n    `specifier, index ${i}`,\n  ));\n  if (errors.some(Boolean)) {\n    throw new TypeError(`\n      sequenceOf: all specifiers must match the appropriate shape.\n\n      Errors:\n        ${errors.map((e, i) => ` - Argument index ${i}: ${e.message}`).join(',\\n        ')}\n    `);\n  }\n\n  const validator = function sequenceOf(props, propName, ...rest) {\n    const { [propName]: propValue } = props;\n\n    if (propValue == null) {\n      return null;\n    }\n\n    const error = array(props, propName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, ...rest);\n  };\n\n  validator.isRequired = function sequenceOfRequired(props, propName, componentName, ...rest) {\n    const error = array.isRequired(props, propName, componentName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(validator, 'sequenceOf', specifiers);\n}\n"]},"metadata":{},"sourceType":"script"}