{"version":3,"sources":["config/connection.tsx","programs/candy-machine.ts","components/Home.tsx","components/App.tsx","reportWebVitals.ts","index.tsx","config/config.ts","utils/utils.ts"],"names":["SequenceType","sendTransactions","connection","wallet","instructionSet","signersSet","a","sequenceType","Parallel","commitment","successCallback","txid","ind","failCallback","block","publicKey","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","i","instructions","signers","length","transaction","Transaction","forEach","instruction","add","recentBlockhash","blockhash","setSigners","map","s","partialSign","push","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","console","log","signedTxnPromise","sendSignedTransaction","signedTransaction","then","slot","catch","reason","StopOnFailure","Promise","all","number","txs","getUnixTs","Date","getTime","DEFAULT_TIMEOUT","timeout","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","done","sleep","awaitTransactionSignatureConfirmation","confirmation","Error","err","error","simulateResult","simulateTransaction","value","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms","MAGIC_HAT_PROGRAM_V2_ID","anchor","PublicKey","getMagicHatState","anchorWallet","magicHatId","provider","preflightCommitment","idl","idlMagicHat","program","account","magicHat","fetch","state","authority","toBase58","itemsAvailable","data","toNumber","itemsRedeemed","itemsRemaining","presale","whitelistMintSettings","goLiveDate","id","isSoldOut","isActive","endSettings","endSettingType","date","isPresale","treasury","tokenMint","gatekeeper","hiddenSettings","price","Home","props","useState","setMagicHat","open","severity","undefined","alertState","setAlertState","classNameState","setIsMobile","setLogoAlphaLoading","whitelists","setCompleted","currentWl","revealLater","setRevealLater","freezeCollection","setFreezeCollection","uploadStep","setUploadStep","useWallet","connect","useMemo","signTransaction","refreshMagicHatState","useCallback","cndy","k","l","completed_c","parseInt","toFixed","useEffect","document","getElementById","clientWidth","changeStep","className","connected","onClick","placeholder","type","height","width","onColor","onChange","checked","pattern","step","Snackbar","autoHideDuration","onClose","Alert","theme","createTheme","palette","process","getMagicHatId","network","rpcHost","REACT_APP_SOLANA_RPC_HOST","Connection","clusterApiUrl","startDateSeed","REACT_APP_CANDY_START_DATE","App","endpoint","wallets","getPhantomWallet","getSolflareWallet","getSlopeWallet","getSolletWallet","getSolletExtensionWallet","ThemeProvider","ConnectionProvider","WalletProvider","autoConnect","startDate","txTimeout","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","TOKEN_PROGRAM_ID","MAGIC_HAT_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","Intl","NumberFormat","style","minimumFractionDigits","maximumFractionDigits","CIVIC","getAtaForMint","mint","buyer","findProgramAddress","toBuffer","getNetworkExpire","gatekeeperNetwork","Buffer","from","getNetworkToken"],"mappings":"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","file":"static/js/main.d3a1f3ff.chunk.js","sourcesContent":["import {\n  Keypair,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from '@solana/web3.js';\n\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string,\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][],\n): Promise<(string | undefined)[]> {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids: string[] = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          'single',\n        );\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const { txs } = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          'single',\n        );\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      'Died on ',\n      stopPoint,\n      'retrying from instruction',\n      instructions[stopPoint],\n      'instructions length is',\n      instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: any,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = 'singleGossip',\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator,\n): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    'Signed txns length',\n    signedTxns.length,\n    'vs handed in length',\n    instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch(reason => {\n        // @ts-ignore\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log('Caught failure', e);\n        if (breakEarlyObject.breakEarly) {\n          console.log('Died on ', breakEarlyObject.i);\n          // Return the txn we failed on by index\n          return {\n            number: breakEarlyObject.i,\n            txs: await Promise.all(pendingTxns),\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    await Promise.all(pendingTxns);\n  }\n\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'recent',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err: any) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            console.log('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection && connection._signatureSubscriptions &&connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import * as anchor from '@project-serum/anchor';\n\nimport { MintLayout, Token } from '@solana/spl-token';\nimport { PublicKey, SystemProgram } from '@solana/web3.js';\nimport { sendTransactions } from '../config/connection';\nimport idlMagicHat from '../idl/magic_hat.json';\n\nimport {\n  CIVIC,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken\n} from '../utils/utils';\nimport { SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, TOKEN_PROGRAM_ID, MAGIC_HAT_ID } from '../config/config';\n// import idl from \"./wallet_whitelist.json\";\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',\n);\n\nconst MAGIC_HAT_PROGRAM_V2_ID = new anchor.web3.PublicKey(\n  'JBw14YzhNTQGqUX54MatDgxDrCPopKf4EGcJHoHfq5ha',\n);\n\ninterface MagicHatState {\n  itemsAvailable: number;\n  itemsRedeemed: number;\n  itemsRemaining: number;\n  treasury: anchor.web3.PublicKey;\n  tokenMint: anchor.web3.PublicKey;\n  isSoldOut: boolean;\n  isActive: boolean;\n  isPresale: boolean;\n  goLiveDate: anchor.BN;\n  price: anchor.BN;\n  gatekeeper: null | {\n    expireOnUse: boolean;\n    gatekeeperNetwork: anchor.web3.PublicKey;\n  };\n  endSettings: null | {\n    number: anchor.BN;\n    endSettingType: any;\n  };\n  whitelistMintSettings: null | {\n    mode: any;\n    mint: anchor.web3.PublicKey;\n    presale: boolean;\n    discountPrice: null | anchor.BN;\n  };\n  hiddenSettings: null | {\n    name: string;\n    uri: string;\n    hash: Uint8Array;\n  };\n}\n\nexport interface MagicHatAccount {\n  id: anchor.web3.PublicKey;\n  program: anchor.Program;\n  state: MagicHatState;\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  queryStatus = false,\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection && connection._signatureSubscriptions && connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log('Returning status', status);\n  return status;\n};\n\nconst createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\nexport const getMagicHatState = async (\n  anchorWallet: anchor.Wallet,\n  magicHatId: anchor.web3.PublicKey,\n  connection: anchor.web3.Connection,\n): Promise<MagicHatAccount> => {\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'recent',\n  });\n\n  const idl:any = idlMagicHat;\n\n  const program = new anchor.Program(idl, MAGIC_HAT_PROGRAM_V2_ID, provider);\n\n  const state: any = await program.account.magicHat.fetch(magicHatId);\n  console.log(state.authority.toBase58());\n  const itemsAvailable = state.data.itemsAvailable.toNumber();\n  const itemsRedeemed = state.itemsRedeemed.toNumber();\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n  const presale =\n    state.data.whitelistMintSettings &&\n    state.data.whitelistMintSettings.presale &&\n    (!state.data.goLiveDate ||\n      state.data.goLiveDate.toNumber() > new Date().getTime() / 1000);\n\n  return {\n    id: magicHatId,\n    program,\n    state: {\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      isSoldOut: itemsRemaining === 0,\n      isActive:\n        (presale ||\n          state.data.goLiveDate?.toNumber() < new Date().getTime() / 1000) &&\n        (state.data.endSettings\n          ? state.data.endSettings.endSettingType.date\n            ? state.data.endSettings.number.toNumber() >\n              new Date().getTime() / 1000\n            : itemsRedeemed < state.data.endSettings.number.toNumber()\n          : true),\n      isPresale: presale,\n      goLiveDate: state.data.goLiveDate,\n      treasury: state.wallet,\n      tokenMint: state.tokenMint,\n      gatekeeper: state.data.gatekeeper,\n      endSettings: state.data.endSettings,\n      whitelistMintSettings: state.data.whitelistMintSettings,\n      hiddenSettings: state.data.hiddenSettings,\n      price: state.data.price,\n    },\n  };\n};\n\nconst getMasterEdition = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getMagicHatCreator = async (\n  magicHat: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from('magic_hat'), magicHat.toBuffer()],\n    MAGIC_HAT_PROGRAM_V2_ID,\n  );\n};\n\nexport const mintOneToken = async (\n  magicHat: MagicHatAccount,\n  payer: anchor.web3.PublicKey,\n  wallet: any,\n  id:any\n): Promise<(string | undefined)[]> => {\n  const mint = anchor.web3.Keypair.generate();\n\n  const userTokenAccountAddress = (\n    await getAtaForMint(mint.publicKey, payer)\n  )[0];\n\n  const userPayingAccountAddress = magicHat.state.tokenMint\n    ? (await getAtaForMint(magicHat.state.tokenMint, payer))[0]\n    : payer;\n\n  const MAGIC_HAT_ID = magicHat.id;\n  console.log(MAGIC_HAT_ID.toBase58());\n  const remainingAccounts = [];\n  const signers: anchor.web3.Keypair[] = [mint];\n  const cleanupInstructions = [];\n  const instructions  = [\n    anchor.web3.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: mint.publicKey,\n      space: MintLayout.span,\n      lamports:\n        await magicHat.program.provider.connection.getMinimumBalanceForRentExemption(\n          MintLayout.span,\n        ),\n      programId: TOKEN_PROGRAM_ID,\n    }),\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      0,\n      payer,\n      payer,\n    ),\n    createAssociatedTokenAccountInstruction(\n      userTokenAccountAddress,\n      payer,\n      payer,\n      mint.publicKey,\n    ),\n    Token.createMintToInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      userTokenAccountAddress,\n      payer,\n      [],\n      1,\n    )\n  ];\n\n  if (magicHat.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (\n        await getNetworkToken(\n          payer,\n          magicHat.state.gatekeeper.gatekeeperNetwork,\n        )\n      )[0],\n      isWritable: true,\n      isSigner: false,\n    });\n    if (magicHat.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkExpire(\n            magicHat.state.gatekeeper.gatekeeperNetwork,\n          )\n        )[0],\n        isWritable: false,\n        isSigner: false,\n      });\n    }\n  }\n  if (magicHat.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(\n      magicHat.state.whitelistMintSettings.mint,\n    );\n\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (magicHat.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists =\n        await magicHat.program.provider.connection.getAccountInfo(\n          whitelistToken,\n        );\n      if (exists) {\n        instructions.push(\n          Token.createApproveInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            whitelistBurnAuthority.publicKey,\n            payer,\n            [],\n            1,\n          ),\n        );\n        cleanupInstructions.push(\n          Token.createRevokeInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            payer,\n            [],\n          ),\n        );\n      }\n    }\n  }\n\n  if (magicHat.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n    for (let index = 0; index < remainingAccounts.length; index++) {\n      let element = remainingAccounts[index];\n      if (element.pubkey === userPayingAccountAddress) {\n        console.log('Already Minted !!!')\n      }\n    }\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false,\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true,\n    });\n\n    instructions.push(\n      Token.createApproveInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        transferAuthority.publicKey,\n        payer,\n        [],\n        magicHat.state.price.toNumber(),\n      ),\n    );\n    cleanupInstructions.push(\n      Token.createRevokeInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        payer,\n        [],\n      ),\n    );\n  }\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const [magicHatCreator, creatorBump] = await getMagicHatCreator(\n    MAGIC_HAT_ID,\n  );\n\n  instructions.push(\n    await magicHat.program.instruction.mintNft(creatorBump, {\n      accounts: {\n        magicHat: MAGIC_HAT_ID,\n        magicHatCreator,\n        payer: payer,\n        wallet: magicHat.state.treasury,\n        metadata: metadataAddress,\n        mint: mint.publicKey,\n        mintAuthority: payer,\n        updateAuthority: payer,\n        masterEdition,\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n        rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n        recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n      },\n      remainingAccounts:\n        remainingAccounts.length > 0 ? remainingAccounts : undefined,\n    }),\n  );\n  try {\n    return (\n      await sendTransactions(\n        magicHat.program.provider.connection,\n        magicHat.program.provider.wallet,\n        [instructions, cleanupInstructions],\n        [signers, []],\n      )\n    ).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\n\nexport const mintOneTokenWL = async (\n  magicHat: MagicHatAccount,\n  payer: anchor.web3.PublicKey,\n  wallet_pda: any\n): Promise<(string | undefined)[]> => {\n  const mint = anchor.web3.Keypair.generate();\n\n  const userTokenAccountAddress = (\n    await getAtaForMint(mint.publicKey, payer)\n  )[0];\n\n  const userPayingAccountAddress = magicHat.state.tokenMint\n    ? (await getAtaForMint(magicHat.state.tokenMint, payer))[0]\n    : payer;\n  const remainingAccounts = [];\n  const signers: anchor.web3.Keypair[] = [mint];\n  const cleanupInstructions = [];\n  const instructions  = [\n    anchor.web3.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: mint.publicKey,\n      space: MintLayout.span,\n      lamports:\n        await magicHat.program.provider.connection.getMinimumBalanceForRentExemption(\n          MintLayout.span,\n        ),\n      programId: TOKEN_PROGRAM_ID,\n    }),\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      0,\n      payer,\n      payer,\n    ),\n    createAssociatedTokenAccountInstruction(\n      userTokenAccountAddress,\n      payer,\n      payer,\n      mint.publicKey,\n    ),\n    Token.createMintToInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      userTokenAccountAddress,\n      payer,\n      [],\n      1,\n    )\n  ];\n\n  if (magicHat.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (\n        await getNetworkToken(\n          payer,\n          magicHat.state.gatekeeper.gatekeeperNetwork,\n        )\n      )[0],\n      isWritable: true,\n      isSigner: false,\n    });\n    if (magicHat.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkExpire(\n            magicHat.state.gatekeeper.gatekeeperNetwork,\n          )\n        )[0],\n        isWritable: false,\n        isSigner: false,\n      });\n    }\n  }\n  if (magicHat.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(\n      magicHat.state.whitelistMintSettings.mint,\n    );\n\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (magicHat.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists =\n        await magicHat.program.provider.connection.getAccountInfo(\n          whitelistToken,\n        );\n      if (exists) {\n        instructions.push(\n          Token.createApproveInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            whitelistBurnAuthority.publicKey,\n            payer,\n            [],\n            1,\n          ),\n        );\n        cleanupInstructions.push(\n          Token.createRevokeInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            payer,\n            [],\n          ),\n        );\n      }\n    }\n  }\n\n  if (magicHat.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n    for (let index = 0; index < remainingAccounts.length; index++) {\n      let element = remainingAccounts[index];\n      if (element.pubkey === userPayingAccountAddress) {\n        console.log('Already Minted !!!')\n      }\n    }\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false,\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true,\n    });\n\n    instructions.push(\n      Token.createApproveInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        transferAuthority.publicKey,\n        payer,\n        [],\n        magicHat.state.price.toNumber(),\n      ),\n    );\n    cleanupInstructions.push(\n      Token.createRevokeInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        payer,\n        [],\n      ),\n    );\n  }\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const [magicHatCreator, creatorBump] = await getMagicHatCreator(\n    MAGIC_HAT_ID,\n  );\n  console.log(MAGIC_HAT_ID.toBase58());\n  instructions.push(\n    await magicHat.program.instruction.wlMintNft(creatorBump, {\n      accounts: {\n        magicHat: MAGIC_HAT_ID,\n        walletWhitelist: wallet_pda,\n        magicHatCreator: magicHatCreator,\n        whitelistedAddress: payer,\n        wallet: magicHat.state.treasury,\n        metadata: metadataAddress,\n        mint: mint.publicKey,\n        mintAuthority: payer,\n        updateAuthority: payer,\n        masterEdition,\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n        rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n        recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n      },\n      remainingAccounts:\n        remainingAccounts.length > 0 ? remainingAccounts : undefined,\n    }),\n  );\n  try {\n    return (\n      await sendTransactions(\n        magicHat.program.provider.connection,\n        magicHat.program.provider.wallet,\n        [instructions, cleanupInstructions],\n        [signers, []],\n      )\n    ).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n","import { useEffect, useMemo, useState, useCallback } from \"react\";\nimport * as anchor from \"@project-serum/anchor\";\nimport { PublicKey, SystemProgram, LAMPORTS_PER_SOL, sendAndConfirmTransaction, Transaction, Connection, GetProgramAccountsFilter, TokenAccountsFilter, clusterApiUrl } from \"@solana/web3.js\";\nimport { Snackbar } from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\nimport { AlertState } from \"../utils/utils\";\nimport {\n  MAGIC_HAT_ID,\n  pdaSeed,\n  pdaWhitelistSeed,\n  MAGIC_HAT_CREATOR,\n  TOKEN_METADATA_PROGRAM_ID,\n  MAGIC_HAT_CREATOR_KEYPAIR,\n  GOG_TIME,\n  WL_TIME,\n  PUBLIC_TIME,\n  COMMUNITY_TIME,\n  GOG_PRICE,\n  OG_PRICE,\n  WL_PRICE,\n  PUBLIC_PRICE,\n  COMMUNITY_PRICE,\n  MAGIC_STAKE_PROGRAM_ID,\n  FARM_ID,\n  TOKEN_PROGRAM_ID,\n  MAHANOTHIA_FARM_ID,\n  BASEMENT_FARM_ID,\n  SAN_CHETOS_FARM_ID,\n  MAGNEXIA_FARM_ID,\n  RAUDCHERI_FARM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  GEM_BANK,\n  COLLECTION_ID,\n  REWARD_MINT,\n  FEE_WALLET\n} from \"../config/config\";\nimport {\n  awaitTransactionSignatureConfirmation,\n  MagicHatAccount,\n  getMagicHatState,\n  mintOneToken,\n  mintOneTokenWL,\n} from \"../programs/candy-machine\";\nimport idl from \"../idl/magic_hat.json\";\nimport idlStake from \"../idl/magic_stake.json\";\nimport idlBank from \"../idl/gem_bank.json\";\nimport { BN, Program } from \"@project-serum/anchor\";\nimport { CircularProgressbar } from 'react-circular-progressbar';\nimport 'react-circular-progressbar/dist/styles.css';\nimport { sendTransactions } from \"../config/connection\";\nimport { getParsedNftAccountsByOwner,isValidSolanaAddress, createConnectionConfig,} from \"@nfteyez/sol-rayz\";\nimport { programs } from \"@metaplex/js\";\nimport { Button, Flex } from \"@chakra-ui/react\";\nimport Switch from \"react-switch\";\n\nconst MAGIC_HAT_PROGRAM_V2_ID = new anchor.web3.PublicKey(\n  \"JBw14YzhNTQGqUX54MatDgxDrCPopKf4EGcJHoHfq5ha\"\n);\n\nconst content = (\n  <div></div>\n);\n\nconst steps = [\n  { label: 'Step 1', content },\n  { label: 'Step 2', content },\n  { label: 'Step 3', content },\n];\n\nconst responsive = {\n  superLargeDesktop: {\n    breakpoint: { max: 4000, min: 3000 },\n    items: 5,\n  },\n  desktop: {\n    breakpoint: { max: 3000, min: 1024 },\n    items: 3,\n  },\n  tablet: {\n    breakpoint: { max: 1024, min: 464 },\n    items: 2,\n  },\n  mobile: {\n    breakpoint: { max: 464, min: 0 },\n    items: 1,\n  },\n};\n\ninterface NFT {\n  pubkey?: PublicKey\n  mint: PublicKey\n  onchainMetadata: programs.metadata.MetadataData\n  externalMetadata: {\n    attributes: Array<any>\n    collection: any\n    description: string\n    edition: number\n    external_url: string\n    image: string\n    name: string\n    properties: {\n      files: Array<string>\n      category: string\n      creators: Array<string>\n    }\n    seller_fee_basis_points: number\n  }\n}\n\nconst RewardType = {\n  Probable: { probable: {} },\n  Fixed: { fixed: {} },\n};\n\nconst LPType = {\n  RESPECT: { respect: {} }\n};\n\n\nexport interface HomeProps {\n  magicHatId?: anchor.web3.PublicKey;\n  connection: anchor.web3.Connection;\n  startDate: number;\n  txTimeout: number;\n  rpcHost: string;\n}\n\nconst Home = (props: HomeProps) => {\n  // const url = window.location.origin;\n  // if (!url.includes('https')) {\n  //   if (url.split(':')[2]) {\n  //     var loc:any = 'https:' + url.split(':')[1] + ':' +  + url.split(':')[2];\n  //     window.location = loc;\n  //   }\n  //   else {\n  //     var loc:any = 'https:' + url.split(':')[1];\n  //     window.location = loc;\n  //   }\n  // }\n  const [isUserMinting, setIsUserMinting] = useState(false);\n  const [magicHat, setMagicHat] = useState<MagicHatAccount>();\n  const [alertState, setAlertState] = useState<AlertState>({\n    open: false,\n    message: \"\",\n    severity: undefined,\n  });\n  const [classNameState, setClassNameState] = useState<string>(\n    \"main-bg-after-door-open black-bg\"\n  );\n  const [isMobile, setIsMobile] = useState(false);\n  const [logoLoading] = useState(false);\n  const [logoAlphaLoading, setLogoAlphaLoading] = useState(true);\n  const [teamInfoMember, setTeamInfoMember] = useState<any>(null);\n  const [whitelists, setWhitelists] = useState<any>(null);\n  const [completed, setCompleted] = useState(0);\n  const [mintCount, setMintCount] = useState(1);\n  const [currentWl, setCurrentWl] = useState(\"\");\n  const [time, setTime] = useState(\"\");\n  const [revealLater, setRevealLater] = useState(false);\n  const [freezeCollection, setFreezeCollection] = useState(false);\n  const [uploadStep, setUploadStep] = useState(1);\n\n  const wallet = useWallet();\n  wallet.connect();\n\n  const anchorWallet = useMemo(() => {\n    // wallet.connect();\n    if (\n      !wallet ||\n      !wallet.publicKey ||\n      !wallet.signAllTransactions ||\n      !wallet.signTransaction\n    ) {\n      return;\n    }\n\n    return {\n      publicKey: wallet.publicKey,\n      signAllTransactions: wallet.signAllTransactions,\n      signTransaction: wallet.signTransaction,\n    } as anchor.Wallet;\n  }, [wallet]);\n\n  const refreshMagicHatState = useCallback(async () => {\n    if (!anchorWallet) {\n      return;\n    }\n\n    if (props.magicHatId) {\n      try {\n        const cndy = await getMagicHatState(\n          anchorWallet,\n          props.magicHatId,\n          props.connection\n        );\n        console.log(JSON.stringify(cndy.state, null, 4));\n        const k: any = cndy?.state.itemsRedeemed.toString()!;\n        const l: any = cndy?.state.itemsAvailable.toString()!;\n        const completed_c: any = ((parseInt(k) / parseInt(l)) * 100).toFixed(0);\n        setCompleted(completed_c);\n        setMagicHat(cndy);\n      } catch (e) {\n        console.log(\"There was a problem fetching Candy Machine state\");\n        console.log(e);\n      }\n    }\n  }, [anchorWallet, props.magicHatId, props.connection]);\n\n  let nftStakeStepCount = 0;\n\n  useEffect(() => {\n    // anchor.Wallet.C;\n    // refreshMagicHatState();\n    var elem: HTMLElement | null = document.getElementById(\"main\");\n    if (elem!.clientWidth < 480) {\n      setIsMobile(true);\n    }\n    // console.log(currentWl);\n    setTimeout(function () {\n      setLogoAlphaLoading(false);\n    }, 900);\n  }, [\n    anchorWallet,\n    props.magicHatId,\n    props.connection,\n    refreshMagicHatState,\n    wallet,\n    whitelists,\n    currentWl,\n  ]);\n\n  let currentWltype: String;\n\n  const changeStep = async (id:any) => {\n    setUploadStep(id);\n  }\n\n  return (\n    <div id=\"main\" className={classNameState}>\n      <div className=\"pull-left full-width\">\n        {wallet && wallet.connected ?\n        (<div className=\"after-connect-div\">\n          <div className=\"launch-collection-div\">\n            <h2 className=\"launch-collection-title\">Launch Collection</h2>\n            <div className=\"Main-collection-upload-steps\">\n              <div onClick={() => changeStep(1)} className={uploadStep == 1 ? \"upload-steps-header active-upload-steps-header\" : \"upload-steps-header\"}>\n                <label className=\"\">Collection<br/>Details</label>\n              </div>\n              <div onClick={() => changeStep(2)} className={uploadStep == 2 ? \"upload-steps-header active-upload-steps-header\" : \"upload-steps-header\"}>\n                <label className=\"\">Upload<br/>Images</label>\n              </div>\n              <div onClick={() => changeStep(3)} className={uploadStep == 3 ? \"upload-steps-header active-upload-steps-header\" : \"upload-steps-header\"}>\n                <label className=\"\">Deploy<br/>on chain</label>\n              </div>\n              <div onClick={() => changeStep(4)} className={uploadStep == 4 ? \"upload-steps-header active-upload-steps-header last-child\" : \"upload-steps-header last-child\"}>\n                <label className=\"\">Mint<br/>Button</label>\n              </div>\n              {uploadStep == 1 &&\n              <div className=\"collection-details-parent\">\n                <div className=\"collection-details-basic\">\n                  <div className=\"collection-details-basic-parent\">\n                    <label>Collection Details</label>\n                    <label className=\"colection-details-label\">Collection Name</label>\n                    <input placeholder=\"Name\" className=\"collection-details-input\" />\n                    <label className=\"colection-details-label\">Symbol</label>\n                    <input placeholder=\"Symbol\" className=\"collection-details-input\" />\n                    <label className=\"colection-details-label\">Launch Date</label>\n                    <input placeholder=\"Symbol\" type=\"date\" className=\"collection-details-input\" />\n                    <label className=\"colection-details-label\">Reveal Later</label>\n                    <Switch height={24} width={50} onColor=\"#2948ff\" onChange={() => setRevealLater(!revealLater)} checked={revealLater} />\n                    <label className=\"colection-details-label\">Freeze Collection</label>\n                    <Switch height={24} width={50} onColor=\"#2948ff\" onChange={() => setFreezeCollection(!freezeCollection)} checked={freezeCollection} />\n                  </div>\n                </div>\n                <div className=\"collection-details-nft\">\n                  <div className=\"collection-details-nft-parent\">\n                    <div className=\"nft-details-first\">\n                      <label>NFT Details</label>\n                      <label className=\"colection-details-label\">Base Art Name</label>\n                      <input placeholder=\"NFT #\" className=\"collection-details-input\" />\n                      <label className=\"colection-details-label\">Description</label>\n                      <textarea placeholder=\"Symbol\" className=\"collection-details-textarea\"></textarea>\n                      <div className=\"hlaf-div\">\n                        <label className=\"colection-details-label\">Mint Cost</label>\n                        <input placeholder=\"0.05\" type=\"number\" pattern=\"[0-9]+([.,][0-9]+)?\" step=\"0.01\" className=\"collection-details-input\" />\n                      </div>\n                      <div className=\"hlaf-div\">\n                        <label className=\"colection-details-label\">Royalities</label>\n                        <input placeholder=\"2.5\" type=\"number\" pattern=\"[0-9]+([.,][0-9]+)?\" step=\"0.01\" className=\"collection-details-input\" />\n                      </div>\n                    </div>\n                    <div className=\"nft-details-second\">\n                      <label>Preview</label>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              }\n            </div>\n          </div>\n        </div>) : (\n        <div className=\"connect-wallet-div\">\n          <WalletDialogButton className=\"Connect-Wallet-btn\">\n            Connect Wallet\n          </WalletDialogButton>\n        </div>)\n        }\n      </div>\n      <Snackbar\n        className=\"snack-bar\"\n        open={alertState.open}\n        autoHideDuration={6000}\n        onClose={() => setAlertState({ ...alertState, open: false })}\n      >\n        <Alert\n          className=\"bold\"\n          onClose={() => setAlertState({ ...alertState, open: false })}\n          severity={alertState.severity}\n        >\n          {alertState.message}\n        </Alert>\n      </Snackbar>\n    </div>\n  );\n};\n\nexport default Home;\n","import '../css/App.css';\nimport { useMemo } from 'react';\nimport * as anchor from '@project-serum/anchor';\nimport Home from './Home';\n\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\nimport {\n  getPhantomWallet,\n  getSlopeWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolletExtensionWallet,\n} from '@solana/wallet-adapter-wallets';\n\nimport {\n  ConnectionProvider,\n  WalletProvider,\n} from '@solana/wallet-adapter-react';\nimport { WalletDialogProvider } from '@solana/wallet-adapter-material-ui';\n\nimport { ThemeProvider, createTheme } from '@material-ui/core';\n\nconst theme = createTheme({\n  palette: {\n    type: 'dark',\n  },\n});\n\nconst getMagicHatId = (): anchor.web3.PublicKey | undefined => {\n  try {\n    const magicHatId = new anchor.web3.PublicKey(\n      process.env.REACT_APP_MAGIC_HAT_ID!,\n    );\n    console.log(magicHatId);\n    return magicHatId;\n  } catch (e) {\n    console.log('Failed to construct MagicHatId', e);\n    return undefined;\n  }\n};\n\nconst magicHatId = getMagicHatId();\nconst network = process.env.REACT_APP_SOLANA_NETWORK as WalletAdapterNetwork;\nconst rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST!;\nconst connection = new anchor.web3.Connection(rpcHost\n  ? rpcHost\n  : anchor.web3.clusterApiUrl('devnet'));\n\nconst startDateSeed = parseInt(process.env.REACT_APP_CANDY_START_DATE!, 10);\nconst txTimeoutInMilliseconds = 30000;\n\nconst App = () => {\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getSlopeWallet(),\n      getSolletWallet({ network }),\n      getSolletExtensionWallet({ network }),\n    ],\n    [],\n  );\n\n  return (\n    <ThemeProvider theme={theme}>\n      <ConnectionProvider endpoint={endpoint}>\n        <WalletProvider wallets={wallets} autoConnect>\n          <WalletDialogProvider>\n            <Home\n              magicHatId={magicHatId}\n              connection={connection}\n              startDate={startDateSeed}\n              txTimeout={txTimeoutInMilliseconds}\n              rpcHost={rpcHost}\n            />\n          </WalletDialogProvider>\n        </WalletProvider>\n      </ConnectionProvider>\n    </ThemeProvider>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { PublicKey, clusterApiUrl } from \"@solana/web3.js\";\n\nexport const MAGIC_HAT_PROGRAM_V2_ID = new PublicKey(\n  \"JBw14YzhNTQGqUX54MatDgxDrCPopKf4EGcJHoHfq5ha\"\n);\n\nexport const MAGIC_HAT_CREATOR_KEYPAIR: any = [];\n\nexport const MAGIC_HAT_CREATOR = new PublicKey(\n  \"H18mLh2oW73KBqRZ53La54qBafEaXBm9bXVefhKnMfXH\"\n);\n\nexport const MAGIC_STAKE_PROGRAM_ID = new PublicKey(\"CMftun186ypSsjsZM8eVfDA7AsPZLoScWpTEYBvCzZVQ\");\n\nexport const FARM_ID = new PublicKey(\"78yzdAb2quRrZWgQi114jdJrsroscWfV3AdVDQYsTFt8\");\n\nexport const MAHANOTHIA_FARM_ID = new PublicKey(\"78yzdAb2quRrZWgQi114jdJrsroscWfV3AdVDQYsTFt8\");\n\nexport const SAN_CHETOS_FARM_ID = new PublicKey(\"78yzdAb2quRrZWgQi114jdJrsroscWfV3AdVDQYsTFt8\");\n\nexport const MAGNEXIA_FARM_ID = new PublicKey(\"78yzdAb2quRrZWgQi114jdJrsroscWfV3AdVDQYsTFt8\");\n\nexport const RAUDCHERI_FARM_ID = new PublicKey(\"78yzdAb2quRrZWgQi114jdJrsroscWfV3AdVDQYsTFt8\");\n\nexport const BASEMENT_FARM_ID = new PublicKey(\"78yzdAb2quRrZWgQi114jdJrsroscWfV3AdVDQYsTFt8\");\n\n\nexport const GEM_BANK = new PublicKey('F4SDKmdyr6pzESeRuew4CkWj2qpTZ1xbn6o7Bvsa9297');\n\nexport const REWARD_MINT = new PublicKey('x4zmbszSajZe8Qg8H1J9s1hMsrDTYjPDe4qp8fJcgMa');\n\nexport const FEE_WALLET = new PublicKey('Bi4UpEtKxnHwCw7b9xkMCouGT6xLNm8nixs2fTmxTevs');\n\nexport const COLLECTION_ID = new PublicKey(\"BNZy4DXcGZRpkkgnQn5nfqnkMPjjh7NLk1KBTe8qqtmZ\");\n\nexport const SYSVAR_CLOCK_PUBKEY = new PublicKey(\n  \"SysvarC1ock11111111111111111111111111111111\"\n);\n\nexport const TOKEN_PROGRAM_ID = new PublicKey(\n  \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n);\n\nexport const SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\n  \"SysvarEpochSchedu1e111111111111111111111111\"\n);\n\nexport const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\n  \"Sysvar1nstructions1111111111111111111111111\"\n);\n\nexport const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\n  \"SysvarRecentB1ockHashes11111111111111111111\"\n);\n\nexport const SYSVAR_RENT_PUBKEY = new PublicKey(\n  \"SysvarRent111111111111111111111111111111111\"\n);\n\nexport const SYSVAR_REWARDS_PUBKEY = new PublicKey(\n  \"SysvarRewards111111111111111111111111111111\"\n);\n\nexport const SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\n  \"SysvarRecentB1ockHashes11111111111111111111\"\n);\n\nexport const SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\n  \"SysvarS1otHistory11111111111111111111111111\"\n);\n\nexport const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\n  \"SysvarStakeHistory1111111111111111111111111\"\n);\n\nexport const MAGIC_HAT_ID = new PublicKey(\n  \"86Yz2W2gh8gyupVhGuX9VxhNV6JoGQqD3RZzixajc4TZ\"\n);\n\nexport const TOKEN_METADATA_PROGRAM_ID = new PublicKey(\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey(\n  \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\n);\n\nexport const pdaSeed = \"wallet-whitelist\";\n\nexport const pdaWhitelistSeed = \"whitelist-config\";\n\nexport const network = clusterApiUrl(\"devnet\");\n\nexport const connectionsOptions = {\n  preflightCommitment: \"processed\",\n};\n\nexport const GOG_TIME = 1656435600;\nexport const WL_TIME = 1656437400;\nexport const PUBLIC_TIME = 1656442800;\nexport const COMMUNITY_TIME = 1656434400;\n\nexport const GOG_PRICE = 1.69;\nexport const OG_PRICE = 1.9;\nexport const WL_PRICE = 1.9;\nexport const PUBLIC_PRICE = 2.29;\nexport const COMMUNITY_PRICE = 0.01;","import * as anchor from '@project-serum/anchor';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport {\n  LAMPORTS_PER_SOL,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\n\nexport interface AlertState {\n  open: boolean;\n  message: string;\n  severity: 'success' | 'info' | 'warning' | 'error' | undefined;\n}\n\nexport const toDate = (value?: anchor.BN) => {\n  if (!value) {\n    return;\n  }\n\n  return new Date(value.toNumber() * 1000);\n};\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n  asNumber: (val?: anchor.BN) => {\n    if (!val) {\n      return undefined;\n    }\n\n    return val.toNumber() / LAMPORTS_PER_SOL;\n  },\n};\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID =\n  new anchor.web3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const CIVIC = new anchor.web3.PublicKey(\n  'gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs',\n);\n\nexport const getAtaForMint = async (\n  mint: anchor.web3.PublicKey,\n  buyer: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  );\n};\n\nexport const getNetworkExpire = async (\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [gatekeeperNetwork.toBuffer(), Buffer.from('expire')],\n    CIVIC,\n  );\n};\n\nexport const getNetworkToken = async (\n  wallet: anchor.web3.PublicKey,\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [\n      wallet.toBuffer(),\n      Buffer.from('gateway'),\n      Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\n      gatekeeperNetwork.toBuffer(),\n    ],\n    CIVIC,\n  );\n};\n\nexport function createAssociatedTokenAccountInstruction(\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n}\n"],"sourceRoot":""}